ONE-PAGE JCF DECISION CHART
ğŸ”¹ LIST (Ordered, duplicates allowed)

Need fast index access (get/set)?
â†’ ArrayList

O(1) get, cache-friendly, default choice

Need FIFO / LIFO behavior?
â†’ ArrayDeque (preferred)
â†’ LinkedList (legacy, avoid unless required)

Need thread-safe, read-heavy list?
â†’ CopyOnWriteArrayList

Writes are costly, reads are lock-free


ğŸ”¹ SET (Unique elements only)

Need uniqueness only (fastest)?
â†’ HashSet
Backed by HashMap, O(1) average

Need sorted unique elements?
â†’ TreeSet
Red-Black Tree, O(log n)

Need uniqueness + insertion order?
â†’ LinkedHashSet
HashSet + doubly-linked list


ğŸ”¹ MAP (Key â†’ Value)

Need the fastest key lookup?
â†’ HashMap
Default map, O(1) average


Need sorted keys / range queries?
â†’ TreeMap
NavigableMap, O(log n)

Need thread-safe map (high concurrency)?
â†’ ConcurrentHashMap
No global lock, segment-based


Need LRU / insertion-ordered cache?
â†’ LinkedHashMap
accessOrder = true â†’ LRU



ğŸ”¹ QUEUE / STACK

FIFO or LIFO (stack/queue/deque)?
â†’ ArrayDeque

Replaces Stack, faster than LinkedList

Priority-based ordering?
â†’ PriorityQueue

Heap, not fully sorted

Producerâ€“Consumer / blocking?
â†’ BlockingQueue

e.g. ArrayBlockingQueue, LinkedBlockingQueue



â€œI default to ArrayList, HashMap, HashSet, and ArrayDeque.
I switch only when I need ordering, priority, or concurrency.â€
âŒ Stack â†’ âœ… ArrayDeque

âŒ Hashtable â†’ âœ… ConcurrentHashMap

LinkedList â†’ rarely justified

If unsure â†’ HashMap / ArrayList first